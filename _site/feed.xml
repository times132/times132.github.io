<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2023-02-07T00:00:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Develop Log</title><author><name>ByungJin Park</name><email>times132@gmail.com</email></author><entry><title type="html">[JPA] @Embedded, @Embeddable</title><link href="http://localhost:4000/java/Embedded.html" rel="alternate" type="text/html" title="[JPA] @Embedded, @Embeddable" /><published>2023-02-06T00:00:00+09:00</published><updated>2023-02-07T00:00:22+09:00</updated><id>http://localhost:4000/java/Embedded</id><content type="html" xml:base="http://localhost:4000/java/Embedded.html"><![CDATA[]]></content><author><name>ByungJin Park</name><email>times132@gmail.com</email></author><category term="java" /><category term="jpa" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[프로그래머스] 부대복귀</title><link href="http://localhost:4000/algorithm/%EB%B6%80%EB%8C%80%EB%B3%B5%EA%B7%80.html" rel="alternate" type="text/html" title="[프로그래머스] 부대복귀" /><published>2022-01-02T00:00:00+09:00</published><updated>2023-01-03T20:08:26+09:00</updated><id>http://localhost:4000/algorithm/%EB%B6%80%EB%8C%80%EB%B3%B5%EA%B7%80</id><content type="html" xml:base="http://localhost:4000/algorithm/%EB%B6%80%EB%8C%80%EB%B3%B5%EA%B7%80.html"><![CDATA[<h3 id="문제-설명">문제 설명</h3>

<p>강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.</p>

<p>강철부대가 위치한 지역을 포함한 총지역의 수 <strong><code class="language-plaintext highlighter-rouge">n</code></strong>, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 <strong><code class="language-plaintext highlighter-rouge">roads</code></strong>, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 <strong><code class="language-plaintext highlighter-rouge">sources</code></strong>, 강철부대의 지역 <strong><code class="language-plaintext highlighter-rouge">destination</code></strong>이 주어졌을 때, 주어진 <strong><code class="language-plaintext highlighter-rouge">sources</code></strong>의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.</p>

<hr />

<h3 id="입력">입력</h3>

<ul>
  <li>3 ≤ <strong><code class="language-plaintext highlighter-rouge">n</code></strong> ≤ 100,000
    <ul>
      <li>각 지역은 정수 1부터 <strong><code class="language-plaintext highlighter-rouge">n</code></strong>까지의 번호로 구분됩니다.</li>
    </ul>
  </li>
  <li>2 ≤ <strong><code class="language-plaintext highlighter-rouge">roads</code></strong>의 길이 ≤ 500,000
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">roads</code></strong>의 원소의 길이 = 2</li>
      <li><strong><code class="language-plaintext highlighter-rouge">roads</code></strong>의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)</li>
      <li>동일한 정보가 중복해서 주어지지 않습니다.
        <ul>
          <li>동일한 [a, b]가 중복해서 주어지지 않습니다.</li>
          <li>[a, b]가 있다면 [b, a]는 주어지지 않습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>1 ≤ <strong><code class="language-plaintext highlighter-rouge">sources</code></strong>의 길이 ≤ 500
    <ul>
      <li>1 ≤ <strong><code class="language-plaintext highlighter-rouge">sources[i]</code></strong> ≤ n</li>
    </ul>
  </li>
  <li>1 ≤ <strong><code class="language-plaintext highlighter-rouge">destination</code></strong> ≤ n</li>
</ul>

<hr />

<h3 id="풀이">풀이</h3>

<p><strong><code class="language-plaintext highlighter-rouge">BFS</code></strong>로 각 노드에서 출발해서 최단 거리를 구하는 방법과 <strong><code class="language-plaintext highlighter-rouge">다익스트라</code></strong> 알고리즘을 이용해 최단 거리를 구하는 방법 중 다익스트라 알고리즘을 사용하였습니다.
<br />
다익스트라는 가중치를 사용하지만 위 문제에는 가중치가 1로 고정되어있어 따로 Node 클래스를 만들지 않았습니다.
<br /></p>

<p>각 노드에서 거리를 기본 <strong><code class="language-plaintext highlighter-rouge">-1</code></strong>로 설정하고 <strong><code class="language-plaintext highlighter-rouge">Dijkstra</code></strong> 함수에서 방문 하지 않은 각 노드를 순환하면서 거리를 +1 하면서 구하는 방식 입니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dist</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">destination</span><span class="o">);</span>
        <span class="n">dist</span><span class="o">[</span><span class="n">destination</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">pq</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pq</span><span class="o">).</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nq</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pq</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">nq</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="n">dist</span><span class="o">[</span><span class="n">nq</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">pq</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nq</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">roads</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sources</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">sources</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">graph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">road</span> <span class="o">:</span> <span class="n">roads</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">road</span><span class="o">[</span><span class="mi">0</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">road</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">road</span><span class="o">[</span><span class="mi">1</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">road</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">Dijkstra</span><span class="o">(</span><span class="n">destination</span><span class="o">);</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">sources</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">[</span><span class="n">sources</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>ByungJin Park</name><email>times132@gmail.com</email></author><category term="algorithm" /><category term="algorithm" /><summary type="html"><![CDATA[문제 설명]]></summary></entry><entry><title type="html">Java 테스트 게시글</title><link href="http://localhost:4000/java/test-java-content.html" rel="alternate" type="text/html" title="Java 테스트 게시글" /><published>2022-01-01T00:00:00+09:00</published><updated>2023-01-03T20:08:26+09:00</updated><id>http://localhost:4000/java/test-java-content</id><content type="html" xml:base="http://localhost:4000/java/test-java-content.html"><![CDATA[<p>자바 관련 내용2</p>]]></content><author><name>ByungJin Park</name><email>times132@gmail.com</email></author><category term="java" /><category term="spring" /><summary type="html"><![CDATA[자바 관련 내용2]]></summary></entry></feed>